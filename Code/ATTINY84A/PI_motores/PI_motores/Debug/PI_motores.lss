
PI_motores.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a9e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00000a9e  00000b32  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001c  0080006e  0080006e  00000b40  2**0
                  ALLOC
  3 .stab         00001f50  00000000  00000000  00000b40  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000707  00000000  00000000  00002a90  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000080  00000000  00000000  00003198  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000b0f  00000000  00000000  00003218  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000307  00000000  00000000  00003d27  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000047d  00000000  00000000  0000402e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000270  00000000  00000000  000044ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000050b  00000000  00000000  0000471c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003a0  00000000  00000000  00004c27  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	1c c0       	rjmp	.+56     	; 0x3a <__ctors_end>
   2:	36 c0       	rjmp	.+108    	; 0x70 <__bad_interrupt>
   4:	35 c0       	rjmp	.+106    	; 0x70 <__bad_interrupt>
   6:	aa c0       	rjmp	.+340    	; 0x15c <__vector_3>
   8:	33 c0       	rjmp	.+102    	; 0x70 <__bad_interrupt>
   a:	32 c0       	rjmp	.+100    	; 0x70 <__bad_interrupt>
   c:	c0 c0       	rjmp	.+384    	; 0x18e <__vector_6>
   e:	30 c0       	rjmp	.+96     	; 0x70 <__bad_interrupt>
  10:	2f c0       	rjmp	.+94     	; 0x70 <__bad_interrupt>
  12:	2e c0       	rjmp	.+92     	; 0x70 <__bad_interrupt>
  14:	2d c0       	rjmp	.+90     	; 0x70 <__bad_interrupt>
  16:	2c c0       	rjmp	.+88     	; 0x70 <__bad_interrupt>
  18:	2b c0       	rjmp	.+86     	; 0x70 <__bad_interrupt>
  1a:	2a c0       	rjmp	.+84     	; 0x70 <__bad_interrupt>
  1c:	29 c0       	rjmp	.+82     	; 0x70 <__bad_interrupt>
  1e:	28 c0       	rjmp	.+80     	; 0x70 <__bad_interrupt>
  20:	cd c0       	rjmp	.+410    	; 0x1bc <__vector_16>
  22:	a3 c2       	rjmp	.+1350   	; 0x56a <_Z14control_parserv+0x24>
  24:	a7 c2       	rjmp	.+1358   	; 0x574 <_Z14control_parserv+0x2e>
  26:	bd c2       	rjmp	.+1402   	; 0x5a2 <_Z14control_parserv+0x5c>
  28:	cd c2       	rjmp	.+1434   	; 0x5c4 <_Z14control_parserv+0x7e>
  2a:	dd c2       	rjmp	.+1466   	; 0x5e6 <_Z14control_parserv+0xa0>
  2c:	ed c2       	rjmp	.+1498   	; 0x608 <_Z14control_parserv+0xc2>
  2e:	fd c2       	rjmp	.+1530   	; 0x62a <_Z14control_parserv+0xe4>
  30:	ae c2       	rjmp	.+1372   	; 0x58e <_Z14control_parserv+0x48>
  32:	b2 c2       	rjmp	.+1380   	; 0x598 <_Z14control_parserv+0x52>
  34:	ff c2       	rjmp	.+1534   	; 0x634 <_Z14control_parserv+0xee>
  36:	a7 c2       	rjmp	.+1358   	; 0x586 <_Z14control_parserv+0x40>
  38:	a1 c2       	rjmp	.+1346   	; 0x57c <_Z14control_parserv+0x36>

0000003a <__ctors_end>:
  3a:	11 24       	eor	r1, r1
  3c:	1f be       	out	0x3f, r1	; 63
  3e:	cf e5       	ldi	r28, 0x5F	; 95
  40:	d2 e0       	ldi	r29, 0x02	; 2
  42:	de bf       	out	0x3e, r29	; 62
  44:	cd bf       	out	0x3d, r28	; 61

00000046 <__do_copy_data>:
  46:	10 e0       	ldi	r17, 0x00	; 0
  48:	a0 e6       	ldi	r26, 0x60	; 96
  4a:	b0 e0       	ldi	r27, 0x00	; 0
  4c:	ee e9       	ldi	r30, 0x9E	; 158
  4e:	fa e0       	ldi	r31, 0x0A	; 10
  50:	02 c0       	rjmp	.+4      	; 0x56 <__do_copy_data+0x10>
  52:	05 90       	lpm	r0, Z+
  54:	0d 92       	st	X+, r0
  56:	ae 36       	cpi	r26, 0x6E	; 110
  58:	b1 07       	cpc	r27, r17
  5a:	d9 f7       	brne	.-10     	; 0x52 <__do_copy_data+0xc>

0000005c <__do_clear_bss>:
  5c:	10 e0       	ldi	r17, 0x00	; 0
  5e:	ae e6       	ldi	r26, 0x6E	; 110
  60:	b0 e0       	ldi	r27, 0x00	; 0
  62:	01 c0       	rjmp	.+2      	; 0x66 <.do_clear_bss_start>

00000064 <.do_clear_bss_loop>:
  64:	1d 92       	st	X+, r1

00000066 <.do_clear_bss_start>:
  66:	aa 38       	cpi	r26, 0x8A	; 138
  68:	b1 07       	cpc	r27, r17
  6a:	e1 f7       	brne	.-8      	; 0x64 <.do_clear_bss_loop>
  6c:	ea d2       	rcall	.+1492   	; 0x642 <main>
  6e:	15 c5       	rjmp	.+2602   	; 0xa9a <_exit>

00000070 <__bad_interrupt>:
  70:	c7 cf       	rjmp	.-114    	; 0x0 <__vectors>

00000072 <_Z13gpio_blinkLedv>:
/************************************************************************/
/* Blink Led. Revisado 25 Feb
 */
/************************************************************************/
void gpio_blinkLed() {
	PORTA |= (1 << LED_PIN);
  72:	db 9a       	sbi	0x1b, 3	; 27
  74:	80 e1       	ldi	r24, 0x10	; 16
  76:	97 e2       	ldi	r25, 0x27	; 39
  78:	01 97       	sbiw	r24, 0x01	; 1
	int i=10000;
	while (i>0){
  7a:	f1 f7       	brne	.-4      	; 0x78 <_Z13gpio_blinkLedv+0x6>
		i--;
	}
	PORTA &= ~(1 << LED_PIN);
  7c:	db 98       	cbi	0x1b, 3	; 27
  7e:	80 e1       	ldi	r24, 0x10	; 16
  80:	97 e2       	ldi	r25, 0x27	; 39
  82:	01 97       	sbiw	r24, 0x01	; 1
	i=10000;
	while (i>0){
  84:	f1 f7       	brne	.-4      	; 0x82 <_Z13gpio_blinkLedv+0x10>
		i--;
	}
}
  86:	08 95       	ret

00000088 <_Z8gpio_puthh>:
//Revisado 25Feb
bool gpio_put(unsigned char pinOut, unsigned char val) {
	//Asserts
	if (pinOut>=8||val>=2) {
  88:	88 30       	cpi	r24, 0x08	; 8
  8a:	08 f5       	brcc	.+66     	; 0xce <_Z8gpio_puthh+0x46>
  8c:	62 30       	cpi	r22, 0x02	; 2
  8e:	08 f5       	brcc	.+66     	; 0xd2 <_Z8gpio_puthh+0x4a>
		return 0;
	}
	//Codigo
	if(val)
  90:	66 23       	and	r22, r22
  92:	71 f0       	breq	.+28     	; 0xb0 <_Z8gpio_puthh+0x28>
		PORTA |= (1<< pinOut);
  94:	4b b3       	in	r20, 0x1b	; 27
  96:	21 e0       	ldi	r18, 0x01	; 1
  98:	30 e0       	ldi	r19, 0x00	; 0
  9a:	b9 01       	movw	r22, r18
  9c:	02 c0       	rjmp	.+4      	; 0xa2 <_Z8gpio_puthh+0x1a>
  9e:	66 0f       	add	r22, r22
  a0:	77 1f       	adc	r23, r23
  a2:	8a 95       	dec	r24
  a4:	e2 f7       	brpl	.-8      	; 0x9e <_Z8gpio_puthh+0x16>
  a6:	cb 01       	movw	r24, r22
  a8:	84 2b       	or	r24, r20
  aa:	8b bb       	out	0x1b, r24	; 27
	else
		PORTA &=~(1<<pinOut);
	return 1;
  ac:	81 e0       	ldi	r24, 0x01	; 1
  ae:	08 95       	ret
	}
	//Codigo
	if(val)
		PORTA |= (1<< pinOut);
	else
		PORTA &=~(1<<pinOut);
  b0:	4b b3       	in	r20, 0x1b	; 27
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	30 e0       	ldi	r19, 0x00	; 0
  b6:	b9 01       	movw	r22, r18
  b8:	02 c0       	rjmp	.+4      	; 0xbe <_Z8gpio_puthh+0x36>
  ba:	66 0f       	add	r22, r22
  bc:	77 1f       	adc	r23, r23
  be:	8a 95       	dec	r24
  c0:	e2 f7       	brpl	.-8      	; 0xba <_Z8gpio_puthh+0x32>
  c2:	cb 01       	movw	r24, r22
  c4:	80 95       	com	r24
  c6:	84 23       	and	r24, r20
  c8:	8b bb       	out	0x1b, r24	; 27
	return 1;
  ca:	81 e0       	ldi	r24, 0x01	; 1
  cc:	08 95       	ret
}
//Revisado 25Feb
bool gpio_put(unsigned char pinOut, unsigned char val) {
	//Asserts
	if (pinOut>=8||val>=2) {
		return 0;
  ce:	80 e0       	ldi	r24, 0x00	; 0
  d0:	08 95       	ret
  d2:	80 e0       	ldi	r24, 0x00	; 0
	if(val)
		PORTA |= (1<< pinOut);
	else
		PORTA &=~(1<<pinOut);
	return 1;
}
  d4:	08 95       	ret

000000d6 <_Z8gpio_geth>:

bool gpio_get(unsigned char pinIn) {
	if (PORTA & pinIn) {
  d6:	9b b3       	in	r25, 0x1b	; 27
  d8:	98 23       	and	r25, r24
	else
		PORTA &=~(1<<pinOut);
	return 1;
}

bool gpio_get(unsigned char pinIn) {
  da:	81 e0       	ldi	r24, 0x01	; 1
  dc:	09 f4       	brne	.+2      	; 0xe0 <_Z8gpio_geth+0xa>
  de:	80 e0       	ldi	r24, 0x00	; 0
	if (PORTA & pinIn) {
		return 1;
	} else {
		return 0;
	}
}
  e0:	08 95       	ret

000000e2 <_Z8pwm_initv>:
 @return bool TRUE si la inicializacion se logra, false de lo contrario
 */
/************************************************************************/
bool pwm_init() {
	// Inicializa el PORTB2 como pin de
	PWM_DIR_REG |= (1<<PWM_PIN);
  e2:	d7 9a       	sbi	0x1a, 7	; 26
	PWM_REG |= (1<<PWM_PIN);
  e4:	df 9a       	sbi	0x1b, 7	; 27
	//Se cambia la configuracion del reloj
	cli();
  e6:	f8 94       	cli
	// No es necesario poner los otros en 0 ya que el Fuse CKDIV8 se apaga
	// i.e. el valor del vector CLKPR es 0x00 por defecto
	CLKPR |= (1<<CLKPCE); 
  e8:	86 b5       	in	r24, 0x26	; 38
  ea:	80 68       	ori	r24, 0x80	; 128
  ec:	86 bd       	out	0x26, r24	; 38
	CLKPR = 0b00000001;
  ee:	81 e0       	ldi	r24, 0x01	; 1
  f0:	86 bd       	out	0x26, r24	; 38
	
	sei();
  f2:	78 94       	sei

	//DDRB |= (1 << DDB2);
	//PORTB |= (1 << PORTB2);

	// Inicializa el PWM en Fast PWM y con pin de salida en B2
	TCCR0A |= (1 << COM0B1) | (1 << WGM01) | (1 << WGM00);
  f4:	80 b7       	in	r24, 0x30	; 48
  f6:	83 62       	ori	r24, 0x23	; 35
  f8:	80 bf       	out	0x30, r24	; 48

	// Configura la frecuencia de oscilacion:    Freq 500Hz @ 1MHz     y     Freq 2kHz @ 4MHz
	//TCCR0B |= (1 << CS01); //Prescaler = 8
	TCCR0B |= (1<<CS00) ;
  fa:	83 b7       	in	r24, 0x33	; 51
  fc:	81 60       	ori	r24, 0x01	; 1
  fe:	83 bf       	out	0x33, r24	; 51
	// Configura el ciclo util inicial en 0%
	OCR0B = 0x00;
 100:	1c be       	out	0x3c, r1	; 60

	return true;
}
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	08 95       	ret

00000106 <_Z9qdec_initv>:
/* Inicializa la funcionalidad de decodificacion de encoder por cuadratura
 @return bool True si la inicialización fue exitosa, false de lo contrario
 */
/************************************************************************/
void qdec_init() {
	cli();
 106:	f8 94       	cli
	/////////////////////////////////////////////
	//			Configuracion del timer
	////////////////////////////////////////////

	// Habilita las interrupciones por comparacion
	TIMSK1 |= (1 << OCIE1A);
 108:	61 9a       	sbi	0x0c, 1	; 12

	// Establece un prescaler de 1024
	TCCR1B |= (1 << CS12) | (1 << CS10);
 10a:	8e b5       	in	r24, 0x2e	; 46
 10c:	85 60       	ori	r24, 0x05	; 5
 10e:	8e bd       	out	0x2e, r24	; 46

	// Establece el valor de comparacion
	OCR1AL = 100;
 110:	84 e6       	ldi	r24, 0x64	; 100
 112:	8a bd       	out	0x2a, r24	; 42
	/////////////////////////////////////////////
	//		Configuracion de interrupcion externa
	////////////////////////////////////////////

	//Habilita la interrupcion externa
	DDRB &= ~(1 << DDA1);
 114:	b9 98       	cbi	0x17, 1	; 23
	//PORTA |= (1 << PORTA1);

	PCMSK0 |= (1<<PCINT1);
 116:	91 9a       	sbi	0x12, 1	; 18
	GIMSK |= (1<<PCIE0);
 118:	8b b7       	in	r24, 0x3b	; 59
 11a:	80 61       	ori	r24, 0x10	; 16
 11c:	8b bf       	out	0x3b, r24	; 59
	sei();
 11e:	78 94       	sei
}
 120:	08 95       	ret

00000122 <_Z13qdec_getSpeedv>:

unsigned char qdec_getSpeed() {
	if (countQDEC>255) {
 122:	80 91 7b 00 	lds	r24, 0x007B
 126:	90 91 7c 00 	lds	r25, 0x007C
 12a:	8f 3f       	cpi	r24, 0xFF	; 255
 12c:	91 05       	cpc	r25, r1
 12e:	39 f0       	breq	.+14     	; 0x13e <_Z13qdec_getSpeedv+0x1c>
 130:	30 f0       	brcs	.+12     	; 0x13e <_Z13qdec_getSpeedv+0x1c>
		countQDEC=255;
 132:	8f ef       	ldi	r24, 0xFF	; 255
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	90 93 7c 00 	sts	0x007C, r25
 13a:	80 93 7b 00 	sts	0x007B, r24
	}
	return countQDEC;
}
 13e:	80 91 7b 00 	lds	r24, 0x007B
 142:	08 95       	ret

00000144 <_Z9init_INT0v>:

/* Configuración de la interrupción INT0*/
void init_INT0(void){
	DDRB |=0<<PB2;  // Se configura PB2 como entrada
 144:	87 b3       	in	r24, 0x17	; 23
 146:	87 bb       	out	0x17, r24	; 23

	MCUCR|=1<<ISC00;  //Se configura el tipo de cambio que hace saltar la interrupción 11->Rising
 148:	85 b7       	in	r24, 0x35	; 53
 14a:	81 60       	ori	r24, 0x01	; 1
 14c:	85 bf       	out	0x35, r24	; 53
	MCUCR|=1<<ISC01;
 14e:	85 b7       	in	r24, 0x35	; 53
 150:	82 60       	ori	r24, 0x02	; 2
 152:	85 bf       	out	0x35, r24	; 53

	GIMSK|=(1<<INT0); //Se cambia la máscara la interrupción del pin INT0
 154:	8b b7       	in	r24, 0x3b	; 59
 156:	80 64       	ori	r24, 0x40	; 64
 158:	8b bf       	out	0x3b, r24	; 59
}
 15a:	08 95       	ret

0000015c <__vector_3>:
// 	PORTA |=(1<<PA0); // PA0 Alto
// 	
// }

ISR(PCINT1_vect)
{
 15c:	1f 92       	push	r1
 15e:	0f 92       	push	r0
 160:	0f b6       	in	r0, 0x3f	; 63
 162:	0f 92       	push	r0
 164:	11 24       	eor	r1, r1
 166:	8f 93       	push	r24
 168:	9f 93       	push	r25
	cli();
 16a:	f8 94       	cli
	//TODO hay que hacer un condicional, dado que puede ocurrir
	//interrupcion por el pin Qdec o por el pin FAULT

	// Hace un conteo de un pulso de la senal index
	countQDEC++;
 16c:	80 91 7b 00 	lds	r24, 0x007B
 170:	90 91 7c 00 	lds	r25, 0x007C
 174:	01 96       	adiw	r24, 0x01	; 1
 176:	90 93 7c 00 	sts	0x007C, r25
 17a:	80 93 7b 00 	sts	0x007B, r24
	sei();
 17e:	78 94       	sei
}
 180:	9f 91       	pop	r25
 182:	8f 91       	pop	r24
 184:	0f 90       	pop	r0
 186:	0f be       	out	0x3f, r0	; 63
 188:	0f 90       	pop	r0
 18a:	1f 90       	pop	r1
 18c:	18 95       	reti

0000018e <__vector_6>:

ISR(TIM1_COMPA_vect)
{
 18e:	1f 92       	push	r1
 190:	0f 92       	push	r0
 192:	0f b6       	in	r0, 0x3f	; 63
 194:	0f 92       	push	r0
 196:	11 24       	eor	r1, r1
 198:	8f 93       	push	r24
	cli();
 19a:	f8 94       	cli
	// Calcula la velocidad angular
	velAct = countQDEC; // -> countQDEC/25;
 19c:	80 91 7b 00 	lds	r24, 0x007B
 1a0:	80 93 7d 00 	sts	0x007D, r24
	// Resetea el timer
	countQDEC = 0;
 1a4:	10 92 7c 00 	sts	0x007C, r1
 1a8:	10 92 7b 00 	sts	0x007B, r1
	TCNT1L = 0;
 1ac:	1c bc       	out	0x2c, r1	; 44

	sei();
 1ae:	78 94       	sei
}
 1b0:	8f 91       	pop	r24
 1b2:	0f 90       	pop	r0
 1b4:	0f be       	out	0x3f, r0	; 63
 1b6:	0f 90       	pop	r0
 1b8:	1f 90       	pop	r1
 1ba:	18 95       	reti

000001bc <__vector_16>:

ISR(USI_OVF_vect)
{
 1bc:	1f 92       	push	r1
 1be:	0f 92       	push	r0
 1c0:	0f b6       	in	r0, 0x3f	; 63
 1c2:	0f 92       	push	r0
 1c4:	11 24       	eor	r1, r1
 1c6:	8f 93       	push	r24
 1c8:	9f 93       	push	r25
	cli();
 1ca:	f8 94       	cli
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
 1cc:	80 e4       	ldi	r24, 0x40	; 64
 1ce:	8e b9       	out	0x0e, r24	; 14
	spi_status.transferComplete = 1;
 1d0:	80 91 6e 00 	lds	r24, 0x006E
 1d4:	82 60       	ori	r24, 0x02	; 2
 1d6:	80 93 6e 00 	sts	0x006E, r24
	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
 1da:	8f b1       	in	r24, 0x0f	; 15
 1dc:	80 93 6f 00 	sts	0x006F, r24
	
	if(primero){
 1e0:	90 91 6c 00 	lds	r25, 0x006C
 1e4:	99 23       	and	r25, r25
 1e6:	81 f0       	breq	.+32     	; 0x208 <__vector_16+0x4c>
		encabezado =storedUSIDR;
 1e8:	80 93 86 00 	sts	0x0086, r24
		if(encabezado == MEDIR_CORRIENTE || encabezado == MEDIR_TEMP || encabezado==MEDIR_VELOCIDAD || encabezado==DAR_ESTADO){
 1ec:	81 30       	cpi	r24, 0x01	; 1
 1ee:	31 f0       	breq	.+12     	; 0x1fc <__vector_16+0x40>
 1f0:	8c 30       	cpi	r24, 0x0C	; 12
 1f2:	21 f0       	breq	.+8      	; 0x1fc <__vector_16+0x40>
 1f4:	82 30       	cpi	r24, 0x02	; 2
 1f6:	11 f0       	breq	.+4      	; 0x1fc <__vector_16+0x40>
 1f8:	8b 30       	cpi	r24, 0x0B	; 11
 1fa:	19 f4       	brne	.+6      	; 0x202 <__vector_16+0x46>
			parsear = true;
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	80 93 87 00 	sts	0x0087, r24
		}
		primero=false;
 202:	10 92 6c 00 	sts	0x006C, r1
 206:	07 c0       	rjmp	.+14     	; 0x216 <__vector_16+0x5a>
	}
	else{
		argumento=storedUSIDR;
 208:	80 93 85 00 	sts	0x0085, r24
		parsear=true;
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	80 93 87 00 	sts	0x0087, r24
		primero=true;
 212:	80 93 6c 00 	sts	0x006C, r24
	}
	
	USIDR = ACK_tiny;
 216:	8b eb       	ldi	r24, 0xBB	; 187
 218:	8f b9       	out	0x0f, r24	; 15
	
	sei();
 21a:	78 94       	sei
}
 21c:	9f 91       	pop	r25
 21e:	8f 91       	pop	r24
 220:	0f 90       	pop	r0
 222:	0f be       	out	0x3f, r0	; 63
 224:	0f 90       	pop	r0
 226:	1f 90       	pop	r1
 228:	18 95       	reti

0000022a <_Z13spi_initslavec>:
 Esta funcion configura la direccion de los pines y el modulo
 */
/************************************************************************/
void spi_initslave(char spi_mode) {
	// Configure port directions.
	USI_DIR_REG |= (1<<USI_DATAOUT_PIN);
 22a:	d5 9a       	sbi	0x1a, 5	; 26
	// Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN);
 22c:	d6 98       	cbi	0x1a, 6	; 26
	// Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN);
 22e:	9b b3       	in	r25, 0x1b	; 27
 230:	90 65       	ori	r25, 0x50	; 80
 232:	9b bb       	out	0x1b, r25	; 27
	// Pull-ups.

	// Configure USI to 3-wire slave mode with overflow interrupt.
	USICR = (1<<USIOIE) | (1<<USIWM0) | (1<<USICS1) | (spi_mode<<USICS0);
 234:	88 0f       	add	r24, r24
 236:	88 0f       	add	r24, r24
 238:	88 65       	ori	r24, 0x58	; 88
 23a:	8d b9       	out	0x0d, r24	; 13

	// Init driver status register.
	spi_status.masterMode = 0;
 23c:	80 91 6e 00 	lds	r24, 0x006E
 240:	8e 7f       	andi	r24, 0xFE	; 254
 242:	80 93 6e 00 	sts	0x006E, r24
	spi_status.transferComplete = 0;
 246:	80 91 6e 00 	lds	r24, 0x006E
 24a:	8d 7f       	andi	r24, 0xFD	; 253
 24c:	80 93 6e 00 	sts	0x006E, r24
	spi_status.writeCollision = 0;
 250:	80 91 6e 00 	lds	r24, 0x006E
 254:	8b 7f       	andi	r24, 0xFB	; 251
 256:	80 93 6e 00 	sts	0x006E, r24
	USIDR = ACK_tiny;
 25a:	8b eb       	ldi	r24, 0xBB	; 187
 25c:	8f b9       	out	0x0f, r24	; 15
	storedUSIDR = 0;
 25e:	10 92 6f 00 	sts	0x006F, r1
}
 262:	08 95       	ret

00000264 <_Z7spi_puth>:
 */
/************************************************************************/
char spi_put(unsigned char val) {
	// Check if transmission in progress,
	// i.e. USI counter unequal to zero.
	if ( (USISR & 0x0F) != 0) {
 264:	2e b1       	in	r18, 0x0e	; 14
 266:	30 e0       	ldi	r19, 0x00	; 0
 268:	2f 70       	andi	r18, 0x0F	; 15
 26a:	30 70       	andi	r19, 0x00	; 0
 26c:	21 15       	cp	r18, r1
 26e:	31 05       	cpc	r19, r1
 270:	39 f0       	breq	.+14     	; 0x280 <_Z7spi_puth+0x1c>
		// Indicate write collision and return.
		spi_status.writeCollision = 1;
 272:	80 91 6e 00 	lds	r24, 0x006E
 276:	84 60       	ori	r24, 0x04	; 4
 278:	80 93 6e 00 	sts	0x006E, r24
		return 0;
 27c:	80 e0       	ldi	r24, 0x00	; 0
 27e:	08 95       	ret
	}

	// Reinit flags.
	spi_status.transferComplete = 0;
 280:	90 91 6e 00 	lds	r25, 0x006E
 284:	9d 7f       	andi	r25, 0xFD	; 253
 286:	90 93 6e 00 	sts	0x006E, r25
	spi_status.writeCollision = 0;
 28a:	90 91 6e 00 	lds	r25, 0x006E
 28e:	9b 7f       	andi	r25, 0xFB	; 251
 290:	90 93 6e 00 	sts	0x006E, r25

	// Put data in USI data register.
	USIDR = val;
 294:	8f b9       	out	0x0f, r24	; 15

	if (spi_status.writeCollision == 0)
 296:	90 91 6e 00 	lds	r25, 0x006E
	// Check if transmission in progress,
	// i.e. USI counter unequal to zero.
	if ( (USISR & 0x0F) != 0) {
		// Indicate write collision and return.
		spi_status.writeCollision = 1;
		return 0;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	92 fd       	sbrc	r25, 2
 29e:	80 e0       	ldi	r24, 0x00	; 0
	USIDR = val;

	if (spi_status.writeCollision == 0)
		return 1;
	return 0;
}
 2a0:	08 95       	ret

000002a2 <_Z7spi_getv>:
 Este metodo se limita a retornar el valor de stored USIDR
 */
/************************************************************************/
unsigned char spi_get() {
	return storedUSIDR;
}
 2a2:	80 91 6f 00 	lds	r24, 0x006F
 2a6:	08 95       	ret

000002a8 <_Z8spi_waitv>:
 Este metodo se asegura que la ejecucion del programa este ocupada hasta
 que ocurra la interrupcion de transferencia completa
 */
/************************************************************************/
void spi_wait() {
	do {
 2a8:	80 91 6e 00 	lds	r24, 0x006E
 2ac:	81 ff       	sbrs	r24, 1
 2ae:	fc cf       	rjmp	.-8      	; 0x2a8 <_Z8spi_waitv>
	} while (spi_status.transferComplete == 0);
}
 2b0:	08 95       	ret

000002b2 <_Z8adc_initv>:
/* Configura ADC.
 */
/************************************************************************/
void adc_init() {
	//PA0
	PRR&=~(1<<PRADC);
 2b2:	00 98       	cbi	0x00, 0	; 0
	ADCSRA|=(1<<ADEN)|(1<<ADPS1)|(1<<ADPS2);
 2b4:	86 b1       	in	r24, 0x06	; 6
 2b6:	86 68       	ori	r24, 0x86	; 134
 2b8:	86 b9       	out	0x06, r24	; 6
	//ADCSRB|=(1<ADLAR);//Configura la lectura de ADC alineada a la izquierda (8bits de precision)
}
 2ba:	08 95       	ret

000002bc <_Z7adc_getv>:

unsigned int adc_get() {
	unsigned int lectura=0;
	ADCSRA|=(1<<ADSC);
 2bc:	36 9a       	sbi	0x06, 6	; 6
	while ((ADCSRA & (1<<ADIF)) != 0x10);
 2be:	34 9b       	sbis	0x06, 4	; 6
 2c0:	fe cf       	rjmp	.-4      	; 0x2be <_Z7adc_getv+0x2>
	//Espera conversion completa
	lectura = ADC;
 2c2:	84 b1       	in	r24, 0x04	; 4
 2c4:	95 b1       	in	r25, 0x05	; 5
	ADCSRA |=(1 << ADIF);
 2c6:	34 9a       	sbi	0x06, 4	; 6
	return lectura;
}
 2c8:	08 95       	ret

000002ca <_Z9gpio_initv>:
/* Configura los pines GPIO
 //TODO*/
/************************************************************************/
void gpio_init() {

	DDRA|=(1<<LED_PIN); //Salidas
 2ca:	d3 9a       	sbi	0x1a, 3	; 26
	DDRA&=~((1<<Sense_PIN)|(1<<INA_PIN)|(1<<VEL_PIN)|(1<<FAULT_PIN)); //Entradas
 2cc:	8a b3       	in	r24, 0x1a	; 26
 2ce:	88 7f       	andi	r24, 0xF8	; 248
 2d0:	8a bb       	out	0x1a, r24	; 26
}
 2d2:	08 95       	ret

000002d4 <_Z22control_getActualSpeedv>:

int control_getActualSpeed(void) {
	return velAct;
}
 2d4:	80 91 7d 00 	lds	r24, 0x007D
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	08 95       	ret

000002dc <_Z15control_piSpeedv>:

int control_piSpeed(void) {
 2dc:	8f 92       	push	r8
 2de:	9f 92       	push	r9
 2e0:	af 92       	push	r10
 2e2:	bf 92       	push	r11
 2e4:	cf 92       	push	r12
 2e6:	df 92       	push	r13
 2e8:	ef 92       	push	r14
 2ea:	ff 92       	push	r15
 2ec:	0f 93       	push	r16
 2ee:	1f 93       	push	r17
 2f0:	cf 93       	push	r28
 2f2:	df 93       	push	r29
	int16_t setPointCorriente;
	float deltaU_V, k1, k2;

	k1 = KP_V + KI_V;
 2f4:	c0 90 68 00 	lds	r12, 0x0068
 2f8:	d0 90 69 00 	lds	r13, 0x0069
 2fc:	e0 90 6a 00 	lds	r14, 0x006A
 300:	f0 90 6b 00 	lds	r15, 0x006B
	k2 = -KP_V;
	int16_t error = spVel- velAct;
 304:	00 91 7e 00 	lds	r16, 0x007E
 308:	10 e0       	ldi	r17, 0x00	; 0
 30a:	80 91 7d 00 	lds	r24, 0x007D
 30e:	08 1b       	sub	r16, r24
 310:	11 09       	sbc	r17, r1
	deltaU_V = k1 * error + k2 * errorAnt_V;
 312:	b8 01       	movw	r22, r16
 314:	88 27       	eor	r24, r24
 316:	77 fd       	sbrc	r23, 7
 318:	80 95       	com	r24
 31a:	98 2f       	mov	r25, r24
 31c:	9f d2       	rcall	.+1342   	; 0x85c <__floatsisf>
 31e:	4b 01       	movw	r8, r22
 320:	5c 01       	movw	r10, r24

int control_piSpeed(void) {
	int16_t setPointCorriente;
	float deltaU_V, k1, k2;

	k1 = KP_V + KI_V;
 322:	c7 01       	movw	r24, r14
 324:	b6 01       	movw	r22, r12
 326:	20 91 64 00 	lds	r18, 0x0064
 32a:	30 91 65 00 	lds	r19, 0x0065
 32e:	40 91 66 00 	lds	r20, 0x0066
 332:	50 91 67 00 	lds	r21, 0x0067
 336:	f7 d1       	rcall	.+1006   	; 0x726 <__addsf3>
 338:	9b 01       	movw	r18, r22
 33a:	ac 01       	movw	r20, r24
	k2 = -KP_V;
	int16_t error = spVel- velAct;
	deltaU_V = k1 * error + k2 * errorAnt_V;
 33c:	c5 01       	movw	r24, r10
 33e:	b4 01       	movw	r22, r8
 340:	41 d3       	rcall	.+1666   	; 0x9c4 <__mulsf3>
 342:	4b 01       	movw	r8, r22
 344:	5c 01       	movw	r10, r24
 346:	60 91 83 00 	lds	r22, 0x0083
 34a:	70 91 84 00 	lds	r23, 0x0084
 34e:	88 27       	eor	r24, r24
 350:	77 fd       	sbrc	r23, 7
 352:	80 95       	com	r24
 354:	98 2f       	mov	r25, r24
 356:	82 d2       	rcall	.+1284   	; 0x85c <__floatsisf>
int control_piSpeed(void) {
	int16_t setPointCorriente;
	float deltaU_V, k1, k2;

	k1 = KP_V + KI_V;
	k2 = -KP_V;
 358:	a7 01       	movw	r20, r14
 35a:	96 01       	movw	r18, r12
 35c:	50 58       	subi	r21, 0x80	; 128
	int16_t error = spVel- velAct;
	deltaU_V = k1 * error + k2 * errorAnt_V;
 35e:	32 d3       	rcall	.+1636   	; 0x9c4 <__mulsf3>
 360:	9b 01       	movw	r18, r22
 362:	ac 01       	movw	r20, r24
 364:	c5 01       	movw	r24, r10
 366:	b4 01       	movw	r22, r8
 368:	de d1       	rcall	.+956    	; 0x726 <__addsf3>

	U_V = U_V + deltaU_V;
 36a:	20 91 7f 00 	lds	r18, 0x007F
 36e:	30 91 80 00 	lds	r19, 0x0080
 372:	40 91 81 00 	lds	r20, 0x0081
 376:	50 91 82 00 	lds	r21, 0x0082
 37a:	d5 d1       	rcall	.+938    	; 0x726 <__addsf3>
 37c:	d6 2f       	mov	r29, r22
 37e:	c7 2f       	mov	r28, r23
 380:	88 2e       	mov	r8, r24
 382:	c9 2e       	mov	r12, r25
 384:	86 2f       	mov	r24, r22
 386:	9c 2f       	mov	r25, r28
 388:	a8 2d       	mov	r26, r8
 38a:	bc 2d       	mov	r27, r12
 38c:	80 93 7f 00 	sts	0x007F, r24
 390:	90 93 80 00 	sts	0x0080, r25
 394:	a0 93 81 00 	sts	0x0081, r26
 398:	b0 93 82 00 	sts	0x0082, r27

	if (U_V > 255) {
 39c:	bc 01       	movw	r22, r24
 39e:	cd 01       	movw	r24, r26
 3a0:	20 e0       	ldi	r18, 0x00	; 0
 3a2:	30 e0       	ldi	r19, 0x00	; 0
 3a4:	4f e7       	ldi	r20, 0x7F	; 127
 3a6:	53 e4       	ldi	r21, 0x43	; 67
 3a8:	09 d3       	rcall	.+1554   	; 0x9bc <__gesf2>
 3aa:	18 16       	cp	r1, r24
 3ac:	6c f4       	brge	.+26     	; 0x3c8 <_Z15control_piSpeedv+0xec>
		U_V = 255;
 3ae:	80 e0       	ldi	r24, 0x00	; 0
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	af e7       	ldi	r26, 0x7F	; 127
 3b4:	b3 e4       	ldi	r27, 0x43	; 67
 3b6:	80 93 7f 00 	sts	0x007F, r24
 3ba:	90 93 80 00 	sts	0x0080, r25
 3be:	a0 93 81 00 	sts	0x0081, r26
 3c2:	b0 93 82 00 	sts	0x0082, r27
 3c6:	17 c0       	rjmp	.+46     	; 0x3f6 <_Z15control_piSpeedv+0x11a>
	} else if (U_V < 0) {
 3c8:	8d 2f       	mov	r24, r29
 3ca:	9c 2f       	mov	r25, r28
 3cc:	a8 2d       	mov	r26, r8
 3ce:	bc 2d       	mov	r27, r12
 3d0:	bc 01       	movw	r22, r24
 3d2:	cd 01       	movw	r24, r26
 3d4:	20 e0       	ldi	r18, 0x00	; 0
 3d6:	30 e0       	ldi	r19, 0x00	; 0
 3d8:	a9 01       	movw	r20, r18
 3da:	09 d2       	rcall	.+1042   	; 0x7ee <__cmpsf2>
 3dc:	88 23       	and	r24, r24
 3de:	5c f4       	brge	.+22     	; 0x3f6 <_Z15control_piSpeedv+0x11a>
		U_V = 0;
 3e0:	80 e0       	ldi	r24, 0x00	; 0
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	dc 01       	movw	r26, r24
 3e6:	80 93 7f 00 	sts	0x007F, r24
 3ea:	90 93 80 00 	sts	0x0080, r25
 3ee:	a0 93 81 00 	sts	0x0081, r26
 3f2:	b0 93 82 00 	sts	0x0082, r27
	}

	setPointCorriente = U_V;
 3f6:	60 91 7f 00 	lds	r22, 0x007F
 3fa:	70 91 80 00 	lds	r23, 0x0080
 3fe:	80 91 81 00 	lds	r24, 0x0081
 402:	90 91 82 00 	lds	r25, 0x0082
 406:	f7 d1       	rcall	.+1006   	; 0x7f6 <__fixsfsi>
	errorAnt_V = error;
 408:	10 93 84 00 	sts	0x0084, r17
 40c:	00 93 83 00 	sts	0x0083, r16

	return setPointCorriente;
}
 410:	86 2f       	mov	r24, r22
 412:	97 2f       	mov	r25, r23
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	1f 91       	pop	r17
 41a:	0f 91       	pop	r16
 41c:	ff 90       	pop	r15
 41e:	ef 90       	pop	r14
 420:	df 90       	pop	r13
 422:	cf 90       	pop	r12
 424:	bf 90       	pop	r11
 426:	af 90       	pop	r10
 428:	9f 90       	pop	r9
 42a:	8f 90       	pop	r8
 42c:	08 95       	ret

0000042e <_Z24control_getActualCurrentv>:

void control_getActualCurrent(void) {
	ADMUX=0;
 42e:	17 b8       	out	0x07, r1	; 7
	curAct=adc_get();
 430:	45 df       	rcall	.-374    	; 0x2bc <_Z7adc_getv>
 432:	80 93 72 00 	sts	0x0072, r24
}
 436:	08 95       	ret

00000438 <_Z15control_getTempv>:

void control_getTemp(void){
	ADMUX=0b00100010;
 438:	82 e2       	ldi	r24, 0x22	; 34
 43a:	87 b9       	out	0x07, r24	; 7
	tempAct= adc_get();
 43c:	3f df       	rcall	.-386    	; 0x2bc <_Z7adc_getv>
 43e:	80 93 71 00 	sts	0x0071, r24
}
 442:	08 95       	ret

00000444 <_Z17control_piCurrentv>:

uint8_t control_piCurrent(void) {
 444:	4f 92       	push	r4
 446:	5f 92       	push	r5
 448:	6f 92       	push	r6
 44a:	7f 92       	push	r7
 44c:	8f 92       	push	r8
 44e:	9f 92       	push	r9
 450:	af 92       	push	r10
 452:	bf 92       	push	r11
 454:	cf 92       	push	r12
 456:	df 92       	push	r13
 458:	ef 92       	push	r14
 45a:	ff 92       	push	r15
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
	int8_t cicloUtil;
	float k1, k2, deltaU_C;

	k1 = KP_C + KI_C;
 460:	c0 90 60 00 	lds	r12, 0x0060
 464:	d0 90 61 00 	lds	r13, 0x0061
 468:	e0 90 62 00 	lds	r14, 0x0062
 46c:	f0 90 63 00 	lds	r15, 0x0063
	k2 = -KP_C;
	int16_t error = spCur-curAct;
 470:	c0 91 73 00 	lds	r28, 0x0073
 474:	d0 e0       	ldi	r29, 0x00	; 0
 476:	80 91 72 00 	lds	r24, 0x0072
 47a:	c8 1b       	sub	r28, r24
 47c:	d1 09       	sbc	r29, r1
	deltaU_C = k1 * error + k2 * errorAnt_C;

	U_C = U_C + deltaU_C;
 47e:	60 91 74 00 	lds	r22, 0x0074
 482:	77 27       	eor	r23, r23
 484:	67 fd       	sbrc	r22, 7
 486:	70 95       	com	r23
 488:	87 2f       	mov	r24, r23
 48a:	97 2f       	mov	r25, r23
 48c:	e7 d1       	rcall	.+974    	; 0x85c <__floatsisf>
 48e:	2b 01       	movw	r4, r22
 490:	3c 01       	movw	r6, r24
	float k1, k2, deltaU_C;

	k1 = KP_C + KI_C;
	k2 = -KP_C;
	int16_t error = spCur-curAct;
	deltaU_C = k1 * error + k2 * errorAnt_C;
 492:	be 01       	movw	r22, r28
 494:	88 27       	eor	r24, r24
 496:	77 fd       	sbrc	r23, 7
 498:	80 95       	com	r24
 49a:	98 2f       	mov	r25, r24
 49c:	df d1       	rcall	.+958    	; 0x85c <__floatsisf>
 49e:	4b 01       	movw	r8, r22
 4a0:	5c 01       	movw	r10, r24

uint8_t control_piCurrent(void) {
	int8_t cicloUtil;
	float k1, k2, deltaU_C;

	k1 = KP_C + KI_C;
 4a2:	c7 01       	movw	r24, r14
 4a4:	b6 01       	movw	r22, r12
 4a6:	20 91 77 00 	lds	r18, 0x0077
 4aa:	30 91 78 00 	lds	r19, 0x0078
 4ae:	40 91 79 00 	lds	r20, 0x0079
 4b2:	50 91 7a 00 	lds	r21, 0x007A
 4b6:	37 d1       	rcall	.+622    	; 0x726 <__addsf3>
 4b8:	9b 01       	movw	r18, r22
 4ba:	ac 01       	movw	r20, r24
	k2 = -KP_C;
	int16_t error = spCur-curAct;
	deltaU_C = k1 * error + k2 * errorAnt_C;
 4bc:	c5 01       	movw	r24, r10
 4be:	b4 01       	movw	r22, r8
 4c0:	81 d2       	rcall	.+1282   	; 0x9c4 <__mulsf3>
 4c2:	4b 01       	movw	r8, r22
 4c4:	5c 01       	movw	r10, r24
 4c6:	60 91 75 00 	lds	r22, 0x0075
 4ca:	70 91 76 00 	lds	r23, 0x0076
 4ce:	88 27       	eor	r24, r24
 4d0:	77 fd       	sbrc	r23, 7
 4d2:	80 95       	com	r24
 4d4:	98 2f       	mov	r25, r24
 4d6:	c2 d1       	rcall	.+900    	; 0x85c <__floatsisf>
uint8_t control_piCurrent(void) {
	int8_t cicloUtil;
	float k1, k2, deltaU_C;

	k1 = KP_C + KI_C;
	k2 = -KP_C;
 4d8:	a7 01       	movw	r20, r14
 4da:	96 01       	movw	r18, r12
 4dc:	50 58       	subi	r21, 0x80	; 128
	int16_t error = spCur-curAct;
	deltaU_C = k1 * error + k2 * errorAnt_C;
 4de:	72 d2       	rcall	.+1252   	; 0x9c4 <__mulsf3>
 4e0:	9b 01       	movw	r18, r22
 4e2:	ac 01       	movw	r20, r24
 4e4:	c5 01       	movw	r24, r10
 4e6:	b4 01       	movw	r22, r8
 4e8:	1e d1       	rcall	.+572    	; 0x726 <__addsf3>
 4ea:	9b 01       	movw	r18, r22
 4ec:	ac 01       	movw	r20, r24

	U_C = U_C + deltaU_C;
 4ee:	c3 01       	movw	r24, r6
 4f0:	b2 01       	movw	r22, r4
 4f2:	19 d1       	rcall	.+562    	; 0x726 <__addsf3>
 4f4:	80 d1       	rcall	.+768    	; 0x7f6 <__fixsfsi>
 4f6:	60 93 74 00 	sts	0x0074, r22

	if (U_C > 250) {
		U_C = 250;
	} else if (U_C < 1) {
 4fa:	16 16       	cp	r1, r22
 4fc:	1c f0       	brlt	.+6      	; 0x504 <_Z17control_piCurrentv+0xc0>
		U_C = 1;
 4fe:	81 e0       	ldi	r24, 0x01	; 1
 500:	80 93 74 00 	sts	0x0074, r24
	}

	cicloUtil = U_C;
 504:	80 91 74 00 	lds	r24, 0x0074
	errorAnt_C = error;
 508:	d0 93 76 00 	sts	0x0076, r29
 50c:	c0 93 75 00 	sts	0x0075, r28

	return cicloUtil;
}
 510:	df 91       	pop	r29
 512:	cf 91       	pop	r28
 514:	ff 90       	pop	r15
 516:	ef 90       	pop	r14
 518:	df 90       	pop	r13
 51a:	cf 90       	pop	r12
 51c:	bf 90       	pop	r11
 51e:	af 90       	pop	r10
 520:	9f 90       	pop	r9
 522:	8f 90       	pop	r8
 524:	7f 90       	pop	r7
 526:	6f 90       	pop	r6
 528:	5f 90       	pop	r5
 52a:	4f 90       	pop	r4
 52c:	08 95       	ret

0000052e <_Z7pwm_seth>:
//!	@param Ciclo util en escala de 0 - 255
//!
//!	@return nothing
//!-------------------------------------------------------------------------------
void pwm_set(uint8_t PWM) {
	if(PWM>0x7F && esBrazo){
 52e:	88 23       	and	r24, r24
 530:	24 f4       	brge	.+8      	; 0x53a <_Z7pwm_seth+0xc>
 532:	90 91 88 00 	lds	r25, 0x0088
 536:	91 11       	cpse	r25, r1
		PWM=0x7F;
 538:	8f e7       	ldi	r24, 0x7F	; 127
	}
	OCR0B = PWM;
 53a:	8c bf       	out	0x3c, r24	; 60
}
 53c:	08 95       	ret

0000053e <_Z5debugh>:


unsigned char debug(unsigned char msg) {
	spi_put(msg);
 53e:	92 de       	rcall	.-732    	; 0x264 <_Z7spi_puth>
	spi_wait();
 540:	b3 de       	rcall	.-666    	; 0x2a8 <_Z8spi_waitv>
	return spi_get();
 542:	af de       	rcall	.-674    	; 0x2a2 <_Z7spi_getv>
}
 544:	08 95       	ret

00000546 <_Z14control_parserv>:

void control_parser(){
	if(parsear){
 546:	80 91 87 00 	lds	r24, 0x0087
 54a:	88 23       	and	r24, r24
 54c:	09 f4       	brne	.+2      	; 0x550 <_Z14control_parserv+0xa>
 54e:	78 c0       	rjmp	.+240    	; 0x640 <_Z14control_parserv+0xfa>
		switch (encabezado){
 550:	80 91 86 00 	lds	r24, 0x0086
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	01 97       	sbiw	r24, 0x01	; 1
 558:	8c 30       	cpi	r24, 0x0C	; 12
 55a:	91 05       	cpc	r25, r1
 55c:	08 f0       	brcs	.+2      	; 0x560 <_Z14control_parserv+0x1a>
 55e:	6e c0       	rjmp	.+220    	; 0x63c <_Z14control_parserv+0xf6>
 560:	8f 5e       	subi	r24, 0xEF	; 239
 562:	9f 4f       	sbci	r25, 0xFF	; 255
 564:	8f 93       	push	r24
 566:	9f 93       	push	r25
 568:	08 95       	ret
			case MEDIR_CORRIENTE:
			control_getActualCurrent();
 56a:	61 df       	rcall	.-318    	; 0x42e <_Z24control_getActualCurrentv>
			spi_put(curAct);
 56c:	80 91 72 00 	lds	r24, 0x0072
 570:	79 de       	rcall	.-782    	; 0x264 <_Z7spi_puth>
			break;
 572:	64 c0       	rjmp	.+200    	; 0x63c <_Z14control_parserv+0xf6>
			case MEDIR_VELOCIDAD:
			control_getActualSpeed();
			spi_put(velAct);
 574:	80 91 7d 00 	lds	r24, 0x007D
 578:	75 de       	rcall	.-790    	; 0x264 <_Z7spi_puth>
			break;
 57a:	60 c0       	rjmp	.+192    	; 0x63c <_Z14control_parserv+0xf6>
			case MEDIR_TEMP:
			control_getTemp();
 57c:	5d df       	rcall	.-326    	; 0x438 <_Z15control_getTempv>
			spi_put(tempAct);
 57e:	80 91 71 00 	lds	r24, 0x0071
 582:	70 de       	rcall	.-800    	; 0x264 <_Z7spi_puth>
			break;
 584:	5b c0       	rjmp	.+182    	; 0x63c <_Z14control_parserv+0xf6>
			case DAR_ESTADO:
			spi_put(ESTADO);
 586:	80 91 89 00 	lds	r24, 0x0089
 58a:	6c de       	rcall	.-808    	; 0x264 <_Z7spi_puth>
			break;
 58c:	57 c0       	rjmp	.+174    	; 0x63c <_Z14control_parserv+0xf6>
			case SP_CORRIENTE:
			spCur=argumento;
 58e:	80 91 85 00 	lds	r24, 0x0085
 592:	80 93 73 00 	sts	0x0073, r24
			break;
 596:	52 c0       	rjmp	.+164    	; 0x63c <_Z14control_parserv+0xf6>
			case SP_VELOCIDAD:
			spVel=argumento;
 598:	80 91 85 00 	lds	r24, 0x0085
 59c:	80 93 7e 00 	sts	0x007E, r24
			break;
 5a0:	4d c0       	rjmp	.+154    	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_KP_V:
			KP_V=argumento;
 5a2:	60 91 85 00 	lds	r22, 0x0085
 5a6:	70 e0       	ldi	r23, 0x00	; 0
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	55 d1       	rcall	.+682    	; 0x858 <__floatunsisf>
 5ae:	dc 01       	movw	r26, r24
 5b0:	cb 01       	movw	r24, r22
 5b2:	80 93 68 00 	sts	0x0068, r24
 5b6:	90 93 69 00 	sts	0x0069, r25
 5ba:	a0 93 6a 00 	sts	0x006A, r26
 5be:	b0 93 6b 00 	sts	0x006B, r27
			break;
 5c2:	3c c0       	rjmp	.+120    	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_KI_V:
			KI_V=argumento;
 5c4:	60 91 85 00 	lds	r22, 0x0085
 5c8:	70 e0       	ldi	r23, 0x00	; 0
 5ca:	80 e0       	ldi	r24, 0x00	; 0
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	44 d1       	rcall	.+648    	; 0x858 <__floatunsisf>
 5d0:	dc 01       	movw	r26, r24
 5d2:	cb 01       	movw	r24, r22
 5d4:	80 93 64 00 	sts	0x0064, r24
 5d8:	90 93 65 00 	sts	0x0065, r25
 5dc:	a0 93 66 00 	sts	0x0066, r26
 5e0:	b0 93 67 00 	sts	0x0067, r27
			break;
 5e4:	2b c0       	rjmp	.+86     	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_KP_C:
			KP_C=argumento;
 5e6:	60 91 85 00 	lds	r22, 0x0085
 5ea:	70 e0       	ldi	r23, 0x00	; 0
 5ec:	80 e0       	ldi	r24, 0x00	; 0
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	33 d1       	rcall	.+614    	; 0x858 <__floatunsisf>
 5f2:	dc 01       	movw	r26, r24
 5f4:	cb 01       	movw	r24, r22
 5f6:	80 93 60 00 	sts	0x0060, r24
 5fa:	90 93 61 00 	sts	0x0061, r25
 5fe:	a0 93 62 00 	sts	0x0062, r26
 602:	b0 93 63 00 	sts	0x0063, r27
			break;
 606:	1a c0       	rjmp	.+52     	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_KI_C:
			KI_C=argumento;
 608:	60 91 85 00 	lds	r22, 0x0085
 60c:	70 e0       	ldi	r23, 0x00	; 0
 60e:	80 e0       	ldi	r24, 0x00	; 0
 610:	90 e0       	ldi	r25, 0x00	; 0
 612:	22 d1       	rcall	.+580    	; 0x858 <__floatunsisf>
 614:	dc 01       	movw	r26, r24
 616:	cb 01       	movw	r24, r22
 618:	80 93 77 00 	sts	0x0077, r24
 61c:	90 93 78 00 	sts	0x0078, r25
 620:	a0 93 79 00 	sts	0x0079, r26
 624:	b0 93 7a 00 	sts	0x007A, r27
			break;
 628:	09 c0       	rjmp	.+18     	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_ESTADO:
			ESTADO=argumento;
 62a:	80 91 85 00 	lds	r24, 0x0085
 62e:	80 93 89 00 	sts	0x0089, r24
			break;
 632:	04 c0       	rjmp	.+8      	; 0x63c <_Z14control_parserv+0xf6>
			case CAMBIAR_PWM:
			PWM=argumento;
 634:	80 91 85 00 	lds	r24, 0x0085
 638:	80 93 70 00 	sts	0x0070, r24
			break;
		}
		parsear=false;
 63c:	10 92 87 00 	sts	0x0087, r1
 640:	08 95       	ret

00000642 <main>:
	}		
}

int main(void) {
	int iC=0;
	gpio_init();
 642:	43 de       	rcall	.-890    	; 0x2ca <_Z9gpio_initv>
	adc_init();
 644:	36 de       	rcall	.-916    	; 0x2b2 <_Z8adc_initv>
	pwm_init();
 646:	4d dd       	rcall	.-1382   	; 0xe2 <_Z8pwm_initv>
	qdec_init();
 648:	5e dd       	rcall	.-1348   	; 0x106 <_Z9qdec_initv>
	spi_initslave(0);
 64a:	80 e0       	ldi	r24, 0x00	; 0
 64c:	ee dd       	rcall	.-1060   	; 0x22a <_Z13spi_initslavec>
	pwm_set(0);
 64e:	80 e0       	ldi	r24, 0x00	; 0
 650:	6e df       	rcall	.-292    	; 0x52e <_Z7pwm_seth>
	ESTADO=MANUAL_EST;
 652:	80 e2       	ldi	r24, 0x20	; 32
 654:	80 93 89 00 	sts	0x0089, r24
	curAct=0;
 658:	10 92 72 00 	sts	0x0072, r1
	spCur=0;
 65c:	10 92 73 00 	sts	0x0073, r1
	sei();
 660:	78 94       	sei
	while (1) {
		control_parser();
 662:	71 df       	rcall	.-286    	; 0x546 <_Z14control_parserv>
		switch (ESTADO) {
 664:	80 91 89 00 	lds	r24, 0x0089
 668:	80 32       	cpi	r24, 0x20	; 32
 66a:	69 f0       	breq	.+26     	; 0x686 <main+0x44>
 66c:	80 33       	cpi	r24, 0x30	; 48
 66e:	91 f0       	breq	.+36     	; 0x694 <main+0x52>
 670:	80 31       	cpi	r24, 0x10	; 16
 672:	f9 f4       	brne	.+62     	; 0x6b2 <main+0x70>
		case AUTO_EST:
			control_getActualSpeed();
			control_getActualCurrent();	
 674:	dc de       	rcall	.-584    	; 0x42e <_Z24control_getActualCurrentv>
			PWM=control_piCurrent();
 676:	e6 de       	rcall	.-564    	; 0x444 <_Z17control_piCurrentv>
 678:	80 93 70 00 	sts	0x0070, r24
			pwm_set(PWM);
 67c:	58 df       	rcall	.-336    	; 0x52e <_Z7pwm_seth>
			gpio_put(LED_PIN,0);
 67e:	83 e0       	ldi	r24, 0x03	; 3
 680:	60 e0       	ldi	r22, 0x00	; 0
 682:	02 dd       	rcall	.-1532   	; 0x88 <_Z8gpio_puthh>
			break;
 684:	ee cf       	rjmp	.-36     	; 0x662 <main+0x20>
		case MANUAL_EST:
			//spCur=127;
			gpio_put(LED_PIN,1);
 686:	83 e0       	ldi	r24, 0x03	; 3
 688:	61 e0       	ldi	r22, 0x01	; 1
 68a:	fe dc       	rcall	.-1540   	; 0x88 <_Z8gpio_puthh>
			pwm_set(PWM);
 68c:	80 91 70 00 	lds	r24, 0x0070
 690:	4e df       	rcall	.-356    	; 0x52e <_Z7pwm_seth>
			break;
 692:	e7 cf       	rjmp	.-50     	; 0x662 <main+0x20>
		case FAIL_EST:
			pwm_set(0);
 694:	80 e0       	ldi	r24, 0x00	; 0
 696:	4b df       	rcall	.-362    	; 0x52e <_Z7pwm_seth>
			errorAnt_C=0;
 698:	10 92 76 00 	sts	0x0076, r1
 69c:	10 92 75 00 	sts	0x0075, r1
			errorAnt_V=0;
 6a0:	10 92 84 00 	sts	0x0084, r1
 6a4:	10 92 83 00 	sts	0x0083, r1
			spi_put(ERROR_tiny);
 6a8:	81 e1       	ldi	r24, 0x11	; 17
 6aa:	dc dd       	rcall	.-1096   	; 0x264 <_Z7spi_puth>
			storedUSIDR=0x00;
 6ac:	10 92 6f 00 	sts	0x006F, r1
			break;
 6b0:	d8 cf       	rjmp	.-80     	; 0x662 <main+0x20>
		default:
			cli();
 6b2:	f8 94       	cli
			gpio_put(LED_PIN, 1);
 6b4:	83 e0       	ldi	r24, 0x03	; 3
 6b6:	61 e0       	ldi	r22, 0x01	; 1
 6b8:	e7 dc       	rcall	.-1586   	; 0x88 <_Z8gpio_puthh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 6ba:	8f e0       	ldi	r24, 0x0F	; 15
 6bc:	97 e2       	ldi	r25, 0x27	; 39
 6be:	01 97       	sbiw	r24, 0x01	; 1
 6c0:	f1 f7       	brne	.-4      	; 0x6be <main+0x7c>
 6c2:	00 c0       	rjmp	.+0      	; 0x6c4 <main+0x82>
 6c4:	00 00       	nop
			_delay_ms(10);
			gpio_put(LED_PIN, 0);
 6c6:	83 e0       	ldi	r24, 0x03	; 3
 6c8:	60 e0       	ldi	r22, 0x00	; 0
 6ca:	de dc       	rcall	.-1604   	; 0x88 <_Z8gpio_puthh>
 6cc:	8f e0       	ldi	r24, 0x0F	; 15
 6ce:	97 e2       	ldi	r25, 0x27	; 39
 6d0:	01 97       	sbiw	r24, 0x01	; 1
 6d2:	f1 f7       	brne	.-4      	; 0x6d0 <main+0x8e>
 6d4:	00 c0       	rjmp	.+0      	; 0x6d6 <main+0x94>
 6d6:	00 00       	nop
			_delay_ms(10);
			
			gpio_put(LED_PIN, 1);
 6d8:	83 e0       	ldi	r24, 0x03	; 3
 6da:	61 e0       	ldi	r22, 0x01	; 1
 6dc:	d5 dc       	rcall	.-1622   	; 0x88 <_Z8gpio_puthh>
 6de:	8f e0       	ldi	r24, 0x0F	; 15
 6e0:	97 e2       	ldi	r25, 0x27	; 39
 6e2:	01 97       	sbiw	r24, 0x01	; 1
 6e4:	f1 f7       	brne	.-4      	; 0x6e2 <main+0xa0>
 6e6:	00 c0       	rjmp	.+0      	; 0x6e8 <main+0xa6>
 6e8:	00 00       	nop
			_delay_ms(10);
			gpio_put(LED_PIN, 0);
 6ea:	83 e0       	ldi	r24, 0x03	; 3
 6ec:	60 e0       	ldi	r22, 0x00	; 0
 6ee:	cc dc       	rcall	.-1640   	; 0x88 <_Z8gpio_puthh>
 6f0:	8f e0       	ldi	r24, 0x0F	; 15
 6f2:	97 e2       	ldi	r25, 0x27	; 39
 6f4:	01 97       	sbiw	r24, 0x01	; 1
 6f6:	f1 f7       	brne	.-4      	; 0x6f4 <main+0xb2>
 6f8:	00 c0       	rjmp	.+0      	; 0x6fa <main+0xb8>
 6fa:	00 00       	nop
			_delay_ms(10);
			
			gpio_put(LED_PIN, 1);
 6fc:	83 e0       	ldi	r24, 0x03	; 3
 6fe:	61 e0       	ldi	r22, 0x01	; 1
 700:	c3 dc       	rcall	.-1658   	; 0x88 <_Z8gpio_puthh>
 702:	8f e0       	ldi	r24, 0x0F	; 15
 704:	97 e2       	ldi	r25, 0x27	; 39
 706:	01 97       	sbiw	r24, 0x01	; 1
 708:	f1 f7       	brne	.-4      	; 0x706 <main+0xc4>
 70a:	00 c0       	rjmp	.+0      	; 0x70c <main+0xca>
 70c:	00 00       	nop
			_delay_ms(10);
			gpio_put(LED_PIN, 0);
 70e:	83 e0       	ldi	r24, 0x03	; 3
 710:	60 e0       	ldi	r22, 0x00	; 0
 712:	ba dc       	rcall	.-1676   	; 0x88 <_Z8gpio_puthh>
 714:	8f e0       	ldi	r24, 0x0F	; 15
 716:	97 e2       	ldi	r25, 0x27	; 39
 718:	01 97       	sbiw	r24, 0x01	; 1
 71a:	f1 f7       	brne	.-4      	; 0x718 <main+0xd6>
 71c:	00 c0       	rjmp	.+0      	; 0x71e <main+0xdc>
 71e:	00 00       	nop
			_delay_ms(10);
			sei();
 720:	78 94       	sei
			break;
 722:	9f cf       	rjmp	.-194    	; 0x662 <main+0x20>

00000724 <__subsf3>:
 724:	50 58       	subi	r21, 0x80	; 128

00000726 <__addsf3>:
 726:	bb 27       	eor	r27, r27
 728:	aa 27       	eor	r26, r26
 72a:	0e d0       	rcall	.+28     	; 0x748 <__addsf3x>
 72c:	0d c1       	rjmp	.+538    	; 0x948 <__fp_round>
 72e:	fe d0       	rcall	.+508    	; 0x92c <__fp_pscA>
 730:	30 f0       	brcs	.+12     	; 0x73e <__addsf3+0x18>
 732:	03 d1       	rcall	.+518    	; 0x93a <__fp_pscB>
 734:	20 f0       	brcs	.+8      	; 0x73e <__addsf3+0x18>
 736:	31 f4       	brne	.+12     	; 0x744 <__addsf3+0x1e>
 738:	9f 3f       	cpi	r25, 0xFF	; 255
 73a:	11 f4       	brne	.+4      	; 0x740 <__addsf3+0x1a>
 73c:	1e f4       	brtc	.+6      	; 0x744 <__addsf3+0x1e>
 73e:	f3 c0       	rjmp	.+486    	; 0x926 <__fp_nan>
 740:	0e f4       	brtc	.+2      	; 0x744 <__addsf3+0x1e>
 742:	e0 95       	com	r30
 744:	e7 fb       	bst	r30, 7
 746:	e9 c0       	rjmp	.+466    	; 0x91a <__fp_inf>

00000748 <__addsf3x>:
 748:	e9 2f       	mov	r30, r25
 74a:	0f d1       	rcall	.+542    	; 0x96a <__fp_split3>
 74c:	80 f3       	brcs	.-32     	; 0x72e <__addsf3+0x8>
 74e:	ba 17       	cp	r27, r26
 750:	62 07       	cpc	r22, r18
 752:	73 07       	cpc	r23, r19
 754:	84 07       	cpc	r24, r20
 756:	95 07       	cpc	r25, r21
 758:	18 f0       	brcs	.+6      	; 0x760 <__addsf3x+0x18>
 75a:	71 f4       	brne	.+28     	; 0x778 <__addsf3x+0x30>
 75c:	9e f5       	brtc	.+102    	; 0x7c4 <__addsf3x+0x7c>
 75e:	27 c1       	rjmp	.+590    	; 0x9ae <__fp_zero>
 760:	0e f4       	brtc	.+2      	; 0x764 <__addsf3x+0x1c>
 762:	e0 95       	com	r30
 764:	0b 2e       	mov	r0, r27
 766:	ba 2f       	mov	r27, r26
 768:	a0 2d       	mov	r26, r0
 76a:	0b 01       	movw	r0, r22
 76c:	b9 01       	movw	r22, r18
 76e:	90 01       	movw	r18, r0
 770:	0c 01       	movw	r0, r24
 772:	ca 01       	movw	r24, r20
 774:	a0 01       	movw	r20, r0
 776:	11 24       	eor	r1, r1
 778:	ff 27       	eor	r31, r31
 77a:	59 1b       	sub	r21, r25
 77c:	99 f0       	breq	.+38     	; 0x7a4 <__addsf3x+0x5c>
 77e:	59 3f       	cpi	r21, 0xF9	; 249
 780:	50 f4       	brcc	.+20     	; 0x796 <__addsf3x+0x4e>
 782:	50 3e       	cpi	r21, 0xE0	; 224
 784:	68 f1       	brcs	.+90     	; 0x7e0 <__addsf3x+0x98>
 786:	1a 16       	cp	r1, r26
 788:	f0 40       	sbci	r31, 0x00	; 0
 78a:	a2 2f       	mov	r26, r18
 78c:	23 2f       	mov	r18, r19
 78e:	34 2f       	mov	r19, r20
 790:	44 27       	eor	r20, r20
 792:	58 5f       	subi	r21, 0xF8	; 248
 794:	f3 cf       	rjmp	.-26     	; 0x77c <__addsf3x+0x34>
 796:	46 95       	lsr	r20
 798:	37 95       	ror	r19
 79a:	27 95       	ror	r18
 79c:	a7 95       	ror	r26
 79e:	f0 40       	sbci	r31, 0x00	; 0
 7a0:	53 95       	inc	r21
 7a2:	c9 f7       	brne	.-14     	; 0x796 <__addsf3x+0x4e>
 7a4:	7e f4       	brtc	.+30     	; 0x7c4 <__addsf3x+0x7c>
 7a6:	1f 16       	cp	r1, r31
 7a8:	ba 0b       	sbc	r27, r26
 7aa:	62 0b       	sbc	r22, r18
 7ac:	73 0b       	sbc	r23, r19
 7ae:	84 0b       	sbc	r24, r20
 7b0:	ba f0       	brmi	.+46     	; 0x7e0 <__addsf3x+0x98>
 7b2:	91 50       	subi	r25, 0x01	; 1
 7b4:	a1 f0       	breq	.+40     	; 0x7de <__addsf3x+0x96>
 7b6:	ff 0f       	add	r31, r31
 7b8:	bb 1f       	adc	r27, r27
 7ba:	66 1f       	adc	r22, r22
 7bc:	77 1f       	adc	r23, r23
 7be:	88 1f       	adc	r24, r24
 7c0:	c2 f7       	brpl	.-16     	; 0x7b2 <__addsf3x+0x6a>
 7c2:	0e c0       	rjmp	.+28     	; 0x7e0 <__addsf3x+0x98>
 7c4:	ba 0f       	add	r27, r26
 7c6:	62 1f       	adc	r22, r18
 7c8:	73 1f       	adc	r23, r19
 7ca:	84 1f       	adc	r24, r20
 7cc:	48 f4       	brcc	.+18     	; 0x7e0 <__addsf3x+0x98>
 7ce:	87 95       	ror	r24
 7d0:	77 95       	ror	r23
 7d2:	67 95       	ror	r22
 7d4:	b7 95       	ror	r27
 7d6:	f7 95       	ror	r31
 7d8:	9e 3f       	cpi	r25, 0xFE	; 254
 7da:	08 f0       	brcs	.+2      	; 0x7de <__addsf3x+0x96>
 7dc:	b3 cf       	rjmp	.-154    	; 0x744 <__addsf3+0x1e>
 7de:	93 95       	inc	r25
 7e0:	88 0f       	add	r24, r24
 7e2:	08 f0       	brcs	.+2      	; 0x7e6 <__addsf3x+0x9e>
 7e4:	99 27       	eor	r25, r25
 7e6:	ee 0f       	add	r30, r30
 7e8:	97 95       	ror	r25
 7ea:	87 95       	ror	r24
 7ec:	08 95       	ret

000007ee <__cmpsf2>:
 7ee:	71 d0       	rcall	.+226    	; 0x8d2 <__fp_cmp>
 7f0:	08 f4       	brcc	.+2      	; 0x7f4 <__cmpsf2+0x6>
 7f2:	81 e0       	ldi	r24, 0x01	; 1
 7f4:	08 95       	ret

000007f6 <__fixsfsi>:
 7f6:	04 d0       	rcall	.+8      	; 0x800 <__fixunssfsi>
 7f8:	68 94       	set
 7fa:	b1 11       	cpse	r27, r1
 7fc:	d9 c0       	rjmp	.+434    	; 0x9b0 <__fp_szero>
 7fe:	08 95       	ret

00000800 <__fixunssfsi>:
 800:	bc d0       	rcall	.+376    	; 0x97a <__fp_splitA>
 802:	88 f0       	brcs	.+34     	; 0x826 <__fixunssfsi+0x26>
 804:	9f 57       	subi	r25, 0x7F	; 127
 806:	90 f0       	brcs	.+36     	; 0x82c <__fixunssfsi+0x2c>
 808:	b9 2f       	mov	r27, r25
 80a:	99 27       	eor	r25, r25
 80c:	b7 51       	subi	r27, 0x17	; 23
 80e:	a0 f0       	brcs	.+40     	; 0x838 <__fixunssfsi+0x38>
 810:	d1 f0       	breq	.+52     	; 0x846 <__fixunssfsi+0x46>
 812:	66 0f       	add	r22, r22
 814:	77 1f       	adc	r23, r23
 816:	88 1f       	adc	r24, r24
 818:	99 1f       	adc	r25, r25
 81a:	1a f0       	brmi	.+6      	; 0x822 <__fixunssfsi+0x22>
 81c:	ba 95       	dec	r27
 81e:	c9 f7       	brne	.-14     	; 0x812 <__fixunssfsi+0x12>
 820:	12 c0       	rjmp	.+36     	; 0x846 <__fixunssfsi+0x46>
 822:	b1 30       	cpi	r27, 0x01	; 1
 824:	81 f0       	breq	.+32     	; 0x846 <__fixunssfsi+0x46>
 826:	c3 d0       	rcall	.+390    	; 0x9ae <__fp_zero>
 828:	b1 e0       	ldi	r27, 0x01	; 1
 82a:	08 95       	ret
 82c:	c0 c0       	rjmp	.+384    	; 0x9ae <__fp_zero>
 82e:	67 2f       	mov	r22, r23
 830:	78 2f       	mov	r23, r24
 832:	88 27       	eor	r24, r24
 834:	b8 5f       	subi	r27, 0xF8	; 248
 836:	39 f0       	breq	.+14     	; 0x846 <__fixunssfsi+0x46>
 838:	b9 3f       	cpi	r27, 0xF9	; 249
 83a:	cc f3       	brlt	.-14     	; 0x82e <__fixunssfsi+0x2e>
 83c:	86 95       	lsr	r24
 83e:	77 95       	ror	r23
 840:	67 95       	ror	r22
 842:	b3 95       	inc	r27
 844:	d9 f7       	brne	.-10     	; 0x83c <__fixunssfsi+0x3c>
 846:	3e f4       	brtc	.+14     	; 0x856 <__fixunssfsi+0x56>
 848:	90 95       	com	r25
 84a:	80 95       	com	r24
 84c:	70 95       	com	r23
 84e:	61 95       	neg	r22
 850:	7f 4f       	sbci	r23, 0xFF	; 255
 852:	8f 4f       	sbci	r24, 0xFF	; 255
 854:	9f 4f       	sbci	r25, 0xFF	; 255
 856:	08 95       	ret

00000858 <__floatunsisf>:
 858:	e8 94       	clt
 85a:	09 c0       	rjmp	.+18     	; 0x86e <__floatsisf+0x12>

0000085c <__floatsisf>:
 85c:	97 fb       	bst	r25, 7
 85e:	3e f4       	brtc	.+14     	; 0x86e <__floatsisf+0x12>
 860:	90 95       	com	r25
 862:	80 95       	com	r24
 864:	70 95       	com	r23
 866:	61 95       	neg	r22
 868:	7f 4f       	sbci	r23, 0xFF	; 255
 86a:	8f 4f       	sbci	r24, 0xFF	; 255
 86c:	9f 4f       	sbci	r25, 0xFF	; 255
 86e:	99 23       	and	r25, r25
 870:	a9 f0       	breq	.+42     	; 0x89c <__floatsisf+0x40>
 872:	f9 2f       	mov	r31, r25
 874:	96 e9       	ldi	r25, 0x96	; 150
 876:	bb 27       	eor	r27, r27
 878:	93 95       	inc	r25
 87a:	f6 95       	lsr	r31
 87c:	87 95       	ror	r24
 87e:	77 95       	ror	r23
 880:	67 95       	ror	r22
 882:	b7 95       	ror	r27
 884:	f1 11       	cpse	r31, r1
 886:	f8 cf       	rjmp	.-16     	; 0x878 <__floatsisf+0x1c>
 888:	fa f4       	brpl	.+62     	; 0x8c8 <__floatsisf+0x6c>
 88a:	bb 0f       	add	r27, r27
 88c:	11 f4       	brne	.+4      	; 0x892 <__floatsisf+0x36>
 88e:	60 ff       	sbrs	r22, 0
 890:	1b c0       	rjmp	.+54     	; 0x8c8 <__floatsisf+0x6c>
 892:	6f 5f       	subi	r22, 0xFF	; 255
 894:	7f 4f       	sbci	r23, 0xFF	; 255
 896:	8f 4f       	sbci	r24, 0xFF	; 255
 898:	9f 4f       	sbci	r25, 0xFF	; 255
 89a:	16 c0       	rjmp	.+44     	; 0x8c8 <__floatsisf+0x6c>
 89c:	88 23       	and	r24, r24
 89e:	11 f0       	breq	.+4      	; 0x8a4 <__floatsisf+0x48>
 8a0:	96 e9       	ldi	r25, 0x96	; 150
 8a2:	11 c0       	rjmp	.+34     	; 0x8c6 <__floatsisf+0x6a>
 8a4:	77 23       	and	r23, r23
 8a6:	21 f0       	breq	.+8      	; 0x8b0 <__floatsisf+0x54>
 8a8:	9e e8       	ldi	r25, 0x8E	; 142
 8aa:	87 2f       	mov	r24, r23
 8ac:	76 2f       	mov	r23, r22
 8ae:	05 c0       	rjmp	.+10     	; 0x8ba <__floatsisf+0x5e>
 8b0:	66 23       	and	r22, r22
 8b2:	71 f0       	breq	.+28     	; 0x8d0 <__floatsisf+0x74>
 8b4:	96 e8       	ldi	r25, 0x86	; 134
 8b6:	86 2f       	mov	r24, r22
 8b8:	70 e0       	ldi	r23, 0x00	; 0
 8ba:	60 e0       	ldi	r22, 0x00	; 0
 8bc:	2a f0       	brmi	.+10     	; 0x8c8 <__floatsisf+0x6c>
 8be:	9a 95       	dec	r25
 8c0:	66 0f       	add	r22, r22
 8c2:	77 1f       	adc	r23, r23
 8c4:	88 1f       	adc	r24, r24
 8c6:	da f7       	brpl	.-10     	; 0x8be <__floatsisf+0x62>
 8c8:	88 0f       	add	r24, r24
 8ca:	96 95       	lsr	r25
 8cc:	87 95       	ror	r24
 8ce:	97 f9       	bld	r25, 7
 8d0:	08 95       	ret

000008d2 <__fp_cmp>:
 8d2:	99 0f       	add	r25, r25
 8d4:	00 08       	sbc	r0, r0
 8d6:	55 0f       	add	r21, r21
 8d8:	aa 0b       	sbc	r26, r26
 8da:	e0 e8       	ldi	r30, 0x80	; 128
 8dc:	fe ef       	ldi	r31, 0xFE	; 254
 8de:	16 16       	cp	r1, r22
 8e0:	17 06       	cpc	r1, r23
 8e2:	e8 07       	cpc	r30, r24
 8e4:	f9 07       	cpc	r31, r25
 8e6:	c0 f0       	brcs	.+48     	; 0x918 <__fp_cmp+0x46>
 8e8:	12 16       	cp	r1, r18
 8ea:	13 06       	cpc	r1, r19
 8ec:	e4 07       	cpc	r30, r20
 8ee:	f5 07       	cpc	r31, r21
 8f0:	98 f0       	brcs	.+38     	; 0x918 <__fp_cmp+0x46>
 8f2:	62 1b       	sub	r22, r18
 8f4:	73 0b       	sbc	r23, r19
 8f6:	84 0b       	sbc	r24, r20
 8f8:	95 0b       	sbc	r25, r21
 8fa:	39 f4       	brne	.+14     	; 0x90a <__fp_cmp+0x38>
 8fc:	0a 26       	eor	r0, r26
 8fe:	61 f0       	breq	.+24     	; 0x918 <__fp_cmp+0x46>
 900:	23 2b       	or	r18, r19
 902:	24 2b       	or	r18, r20
 904:	25 2b       	or	r18, r21
 906:	21 f4       	brne	.+8      	; 0x910 <__fp_cmp+0x3e>
 908:	08 95       	ret
 90a:	0a 26       	eor	r0, r26
 90c:	09 f4       	brne	.+2      	; 0x910 <__fp_cmp+0x3e>
 90e:	a1 40       	sbci	r26, 0x01	; 1
 910:	a6 95       	lsr	r26
 912:	8f ef       	ldi	r24, 0xFF	; 255
 914:	81 1d       	adc	r24, r1
 916:	81 1d       	adc	r24, r1
 918:	08 95       	ret

0000091a <__fp_inf>:
 91a:	97 f9       	bld	r25, 7
 91c:	9f 67       	ori	r25, 0x7F	; 127
 91e:	80 e8       	ldi	r24, 0x80	; 128
 920:	70 e0       	ldi	r23, 0x00	; 0
 922:	60 e0       	ldi	r22, 0x00	; 0
 924:	08 95       	ret

00000926 <__fp_nan>:
 926:	9f ef       	ldi	r25, 0xFF	; 255
 928:	80 ec       	ldi	r24, 0xC0	; 192
 92a:	08 95       	ret

0000092c <__fp_pscA>:
 92c:	00 24       	eor	r0, r0
 92e:	0a 94       	dec	r0
 930:	16 16       	cp	r1, r22
 932:	17 06       	cpc	r1, r23
 934:	18 06       	cpc	r1, r24
 936:	09 06       	cpc	r0, r25
 938:	08 95       	ret

0000093a <__fp_pscB>:
 93a:	00 24       	eor	r0, r0
 93c:	0a 94       	dec	r0
 93e:	12 16       	cp	r1, r18
 940:	13 06       	cpc	r1, r19
 942:	14 06       	cpc	r1, r20
 944:	05 06       	cpc	r0, r21
 946:	08 95       	ret

00000948 <__fp_round>:
 948:	09 2e       	mov	r0, r25
 94a:	03 94       	inc	r0
 94c:	00 0c       	add	r0, r0
 94e:	11 f4       	brne	.+4      	; 0x954 <__fp_round+0xc>
 950:	88 23       	and	r24, r24
 952:	52 f0       	brmi	.+20     	; 0x968 <__fp_round+0x20>
 954:	bb 0f       	add	r27, r27
 956:	40 f4       	brcc	.+16     	; 0x968 <__fp_round+0x20>
 958:	bf 2b       	or	r27, r31
 95a:	11 f4       	brne	.+4      	; 0x960 <__fp_round+0x18>
 95c:	60 ff       	sbrs	r22, 0
 95e:	04 c0       	rjmp	.+8      	; 0x968 <__fp_round+0x20>
 960:	6f 5f       	subi	r22, 0xFF	; 255
 962:	7f 4f       	sbci	r23, 0xFF	; 255
 964:	8f 4f       	sbci	r24, 0xFF	; 255
 966:	9f 4f       	sbci	r25, 0xFF	; 255
 968:	08 95       	ret

0000096a <__fp_split3>:
 96a:	57 fd       	sbrc	r21, 7
 96c:	90 58       	subi	r25, 0x80	; 128
 96e:	44 0f       	add	r20, r20
 970:	55 1f       	adc	r21, r21
 972:	59 f0       	breq	.+22     	; 0x98a <__fp_splitA+0x10>
 974:	5f 3f       	cpi	r21, 0xFF	; 255
 976:	71 f0       	breq	.+28     	; 0x994 <__fp_splitA+0x1a>
 978:	47 95       	ror	r20

0000097a <__fp_splitA>:
 97a:	88 0f       	add	r24, r24
 97c:	97 fb       	bst	r25, 7
 97e:	99 1f       	adc	r25, r25
 980:	61 f0       	breq	.+24     	; 0x99a <__fp_splitA+0x20>
 982:	9f 3f       	cpi	r25, 0xFF	; 255
 984:	79 f0       	breq	.+30     	; 0x9a4 <__fp_splitA+0x2a>
 986:	87 95       	ror	r24
 988:	08 95       	ret
 98a:	12 16       	cp	r1, r18
 98c:	13 06       	cpc	r1, r19
 98e:	14 06       	cpc	r1, r20
 990:	55 1f       	adc	r21, r21
 992:	f2 cf       	rjmp	.-28     	; 0x978 <__fp_split3+0xe>
 994:	46 95       	lsr	r20
 996:	f1 df       	rcall	.-30     	; 0x97a <__fp_splitA>
 998:	08 c0       	rjmp	.+16     	; 0x9aa <__fp_splitA+0x30>
 99a:	16 16       	cp	r1, r22
 99c:	17 06       	cpc	r1, r23
 99e:	18 06       	cpc	r1, r24
 9a0:	99 1f       	adc	r25, r25
 9a2:	f1 cf       	rjmp	.-30     	; 0x986 <__fp_splitA+0xc>
 9a4:	86 95       	lsr	r24
 9a6:	71 05       	cpc	r23, r1
 9a8:	61 05       	cpc	r22, r1
 9aa:	08 94       	sec
 9ac:	08 95       	ret

000009ae <__fp_zero>:
 9ae:	e8 94       	clt

000009b0 <__fp_szero>:
 9b0:	bb 27       	eor	r27, r27
 9b2:	66 27       	eor	r22, r22
 9b4:	77 27       	eor	r23, r23
 9b6:	cb 01       	movw	r24, r22
 9b8:	97 f9       	bld	r25, 7
 9ba:	08 95       	ret

000009bc <__gesf2>:
 9bc:	8a df       	rcall	.-236    	; 0x8d2 <__fp_cmp>
 9be:	08 f4       	brcc	.+2      	; 0x9c2 <__gesf2+0x6>
 9c0:	8f ef       	ldi	r24, 0xFF	; 255
 9c2:	08 95       	ret

000009c4 <__mulsf3>:
 9c4:	0a d0       	rcall	.+20     	; 0x9da <__mulsf3x>
 9c6:	c0 cf       	rjmp	.-128    	; 0x948 <__fp_round>
 9c8:	b1 df       	rcall	.-158    	; 0x92c <__fp_pscA>
 9ca:	28 f0       	brcs	.+10     	; 0x9d6 <__mulsf3+0x12>
 9cc:	b6 df       	rcall	.-148    	; 0x93a <__fp_pscB>
 9ce:	18 f0       	brcs	.+6      	; 0x9d6 <__mulsf3+0x12>
 9d0:	95 23       	and	r25, r21
 9d2:	09 f0       	breq	.+2      	; 0x9d6 <__mulsf3+0x12>
 9d4:	a2 cf       	rjmp	.-188    	; 0x91a <__fp_inf>
 9d6:	a7 cf       	rjmp	.-178    	; 0x926 <__fp_nan>
 9d8:	eb cf       	rjmp	.-42     	; 0x9b0 <__fp_szero>

000009da <__mulsf3x>:
 9da:	c7 df       	rcall	.-114    	; 0x96a <__fp_split3>
 9dc:	a8 f3       	brcs	.-22     	; 0x9c8 <__mulsf3+0x4>

000009de <__mulsf3_pse>:
 9de:	99 23       	and	r25, r25
 9e0:	d9 f3       	breq	.-10     	; 0x9d8 <__mulsf3+0x14>
 9e2:	55 23       	and	r21, r21
 9e4:	c9 f3       	breq	.-14     	; 0x9d8 <__mulsf3+0x14>
 9e6:	95 0f       	add	r25, r21
 9e8:	50 e0       	ldi	r21, 0x00	; 0
 9ea:	55 1f       	adc	r21, r21
 9ec:	aa 27       	eor	r26, r26
 9ee:	ee 27       	eor	r30, r30
 9f0:	ff 27       	eor	r31, r31
 9f2:	bb 27       	eor	r27, r27
 9f4:	00 24       	eor	r0, r0
 9f6:	08 94       	sec
 9f8:	67 95       	ror	r22
 9fa:	20 f4       	brcc	.+8      	; 0xa04 <__mulsf3_pse+0x26>
 9fc:	e2 0f       	add	r30, r18
 9fe:	f3 1f       	adc	r31, r19
 a00:	b4 1f       	adc	r27, r20
 a02:	0a 1e       	adc	r0, r26
 a04:	22 0f       	add	r18, r18
 a06:	33 1f       	adc	r19, r19
 a08:	44 1f       	adc	r20, r20
 a0a:	aa 1f       	adc	r26, r26
 a0c:	66 95       	lsr	r22
 a0e:	a9 f7       	brne	.-22     	; 0x9fa <__mulsf3_pse+0x1c>
 a10:	77 95       	ror	r23
 a12:	30 f4       	brcc	.+12     	; 0xa20 <__mulsf3_pse+0x42>
 a14:	f3 0f       	add	r31, r19
 a16:	b4 1f       	adc	r27, r20
 a18:	0a 1e       	adc	r0, r26
 a1a:	12 1e       	adc	r1, r18
 a1c:	08 f4       	brcc	.+2      	; 0xa20 <__mulsf3_pse+0x42>
 a1e:	63 95       	inc	r22
 a20:	33 0f       	add	r19, r19
 a22:	44 1f       	adc	r20, r20
 a24:	aa 1f       	adc	r26, r26
 a26:	22 1f       	adc	r18, r18
 a28:	76 95       	lsr	r23
 a2a:	99 f7       	brne	.-26     	; 0xa12 <__mulsf3_pse+0x34>
 a2c:	87 95       	ror	r24
 a2e:	20 f4       	brcc	.+8      	; 0xa38 <__mulsf3_pse+0x5a>
 a30:	b4 0f       	add	r27, r20
 a32:	0a 1e       	adc	r0, r26
 a34:	12 1e       	adc	r1, r18
 a36:	63 1f       	adc	r22, r19
 a38:	44 0f       	add	r20, r20
 a3a:	aa 1f       	adc	r26, r26
 a3c:	22 1f       	adc	r18, r18
 a3e:	33 1f       	adc	r19, r19
 a40:	86 95       	lsr	r24
 a42:	a9 f7       	brne	.-22     	; 0xa2e <__mulsf3_pse+0x50>
 a44:	86 2f       	mov	r24, r22
 a46:	71 2d       	mov	r23, r1
 a48:	60 2d       	mov	r22, r0
 a4a:	11 24       	eor	r1, r1
 a4c:	9f 57       	subi	r25, 0x7F	; 127
 a4e:	50 40       	sbci	r21, 0x00	; 0
 a50:	8a f0       	brmi	.+34     	; 0xa74 <__mulsf3_pse+0x96>
 a52:	e1 f0       	breq	.+56     	; 0xa8c <__mulsf3_pse+0xae>
 a54:	88 23       	and	r24, r24
 a56:	4a f0       	brmi	.+18     	; 0xa6a <__mulsf3_pse+0x8c>
 a58:	ee 0f       	add	r30, r30
 a5a:	ff 1f       	adc	r31, r31
 a5c:	bb 1f       	adc	r27, r27
 a5e:	66 1f       	adc	r22, r22
 a60:	77 1f       	adc	r23, r23
 a62:	88 1f       	adc	r24, r24
 a64:	91 50       	subi	r25, 0x01	; 1
 a66:	50 40       	sbci	r21, 0x00	; 0
 a68:	a9 f7       	brne	.-22     	; 0xa54 <__mulsf3_pse+0x76>
 a6a:	9e 3f       	cpi	r25, 0xFE	; 254
 a6c:	51 05       	cpc	r21, r1
 a6e:	70 f0       	brcs	.+28     	; 0xa8c <__mulsf3_pse+0xae>
 a70:	54 cf       	rjmp	.-344    	; 0x91a <__fp_inf>
 a72:	9e cf       	rjmp	.-196    	; 0x9b0 <__fp_szero>
 a74:	5f 3f       	cpi	r21, 0xFF	; 255
 a76:	ec f3       	brlt	.-6      	; 0xa72 <__mulsf3_pse+0x94>
 a78:	98 3e       	cpi	r25, 0xE8	; 232
 a7a:	dc f3       	brlt	.-10     	; 0xa72 <__mulsf3_pse+0x94>
 a7c:	86 95       	lsr	r24
 a7e:	77 95       	ror	r23
 a80:	67 95       	ror	r22
 a82:	b7 95       	ror	r27
 a84:	f7 95       	ror	r31
 a86:	e7 95       	ror	r30
 a88:	9f 5f       	subi	r25, 0xFF	; 255
 a8a:	c1 f7       	brne	.-16     	; 0xa7c <__mulsf3_pse+0x9e>
 a8c:	fe 2b       	or	r31, r30
 a8e:	88 0f       	add	r24, r24
 a90:	91 1d       	adc	r25, r1
 a92:	96 95       	lsr	r25
 a94:	87 95       	ror	r24
 a96:	97 f9       	bld	r25, 7
 a98:	08 95       	ret

00000a9a <_exit>:
 a9a:	f8 94       	cli

00000a9c <__stop_program>:
 a9c:	ff cf       	rjmp	.-2      	; 0xa9c <__stop_program>
